import { timestamp, files, shell } from '@sapper/service-worker';

const ASSETS = `cache${timestamp}`;

// `shell` is an array of all the files generated by the bundler,
// `files` is an array of everything in the `static` directory
const to_cache = shell.concat(files);
const staticAssets = new Set(to_cache);

let notifications = 0
let ids = []

self.addEventListener('notificationclick', (ev)=>{
  ev.notification.close()
  ev.waitUntil(
    self.clients.matchAll({type: 'window'})
  ).then((clients)=>{
    for (let client of clients){
      if(client.url == '/' && 'focus' in client){
        return client.focus()
      }
    }
    if(clients.openWindow){
      return clients.openWindow('/rooms')
    }
    notifications = 0
    ids=[]
  })
})

self.addEventListener('push', (ev)=>{
  ev.waitUntil(
    self.clients.matchAll({type: 'window'})
    .then(async(clients)=>{
      let id = ev.data.json().id
      if(!ids.includes(id)) ids.push(id)
      for (let client of clients){
        if(client.focused){
          return
        }
      }
      let image = `${self.origin}/x369-144.png`
      let options = {
        badge: image,
        icon: image
      }
      notifications++
      let title = `${notifications} ${(notifications > 1) ? 'New messages':'New message'}`
      self.registration.showNotification(title, options)
    })
  )
})

self.addEventListener('install', event => {
	event.waitUntil(
		caches
			.open(ASSETS)
			.then(cache => cache.addAll(to_cache))
			.then(() => {
				self.skipWaiting();
			})
	);
});

self.addEventListener('activate', event => {
	event.waitUntil(
		caches.keys().then(async keys => {
			// delete old caches
			for (const key of keys) {
				if (key !== ASSETS) await caches.delete(key);
			}

			self.clients.claim();
		})
	);
});


/**
 * Fetch the asset from the network and store it in the cache. 
 * Fall back to the cache if the user is offline.
 */
async function fetchAndCache(request) {
	return caches.open(`offline${timestamp}`).then(cache => {
		return fetch(request).then(netRes => {
			cache.put(request, netRes.clone())
			return netRes || cache.match(request)
		}).catch(err => {
			return cache.match(request)
		})
	})

	// return caches.open(`offline${timestamp}`).then(cache => {
	// 	return cache.match(request).then(cacheRes => {
	// 		return cacheRes || fetch(request).then(netRes=>{
	// 			cache.put(request, netRes.clone())
	// 			return netRes
	// 		})
	// 	})
	// })
}

self.addEventListener('fetch', event => {
	if (event.request.method !== 'GET' || event.request.headers.has('range')) return;

	const url = new URL(event.request.url);

	// don't try to handle e.g. data: URIs
	const isHttp = url.protocol.startsWith('http');
	const isDevServerRequest = url.hostname === self.location.hostname && url.port !== self.location.port;
	const isStaticAsset = url.host === self.location.host && staticAssets.has(url.pathname);
	const skipBecauseUncached = event.request.cache === 'only-if-cached' && !isStaticAsset;

	if (isHttp && !isDevServerRequest && !skipBecauseUncached) {
		event.respondWith(
			(async () => {
				// always serve static files and bundler-generated assets from cache.
				// if your application has other URLs with data that will never change,
				// set this variable to true for them and they will only be fetched once.
				const cachedAsset = isStaticAsset && await caches.match(event.request);

				// for pages, you might want to serve a shell `service-worker-index.html` file,
				// which Sapper has generated for you. It's not right for every
				// app, but if it's right for yours then uncomment this section
				/*
				if (!cachedAsset && url.origin === self.origin && routes.find(route => route.pattern.test(url.pathname))) {
					return caches.match('/service-worker-index.html');
				}
				*/

				return cachedAsset || fetchAndCache(event.request);
			})()
		);
	}
});